package stalbans.inertiagames;import java.lang.*;import java.util.*;import java.awt.*;import javax.swing.*;import javax.swing.border.*;/*How do you use this?  First, you need to subclass this class, override	protected void paintGameScreen(Graphics g)	public boolean crashed()	public boolean gameOver()You shouldn't need to override anything else.  paintGameScreen() allows you to paintthe screen features that the rocket has to work with.  crashed() should return true whenthe rocket has crashed -- by default, that is when the rocket has left the screen.  gameOver()should return true if the user has won the game.  paintGameScreen() and gameOver() are bothabstract, so you _need_ to implement them.To actually use the class, you need to call the following, in addition to any other setupyou do to put it in the enclosing screen:	myPanel.setRocket(some Rocket here)	myPanel.setGameStatusLabel(some JLabel here)then, once everything else has been done, call	myPanel.start()You also need to call the constructor with some class that implements RocketPanelCreatorThe rest you can do as you like.  I would create a kick button as a subclass of JButton.To make it active, you can do:	myKickButton.addActionListener(new ActionListener() {		public void actionPerformed(ActionEvent e) {			myPanel.getRocket().kick();		}	});	A rotate button would be	myRotateButton.addActionListener(new ActionListener() {		public void actionPerformed(ActionEvent e) {			myPanel.getRocket().rotateR(); 					// or rotateL()		}	});You can create a JCheckBox for toggling the tracking:	myTrackingToggle.addActionListener(new ActionListener() {		public void actionPerformed(ActionEvent e) {			myPanel.toggleTracking();		}	});	You could also create a slider that could change the animation delay, using	myPanel.setWaitTime(int t)*/public abstract class RocketPanel extends JPanel implements Runnable {		// note that theRocket, gameStatusLabel, and timeToWait are the only	// variables available to subclasses.  This is because nothing else should	// be messed with...		protected Rocket theRocket;	private Vector theTrail = new Vector();					// for tracking purposes	private boolean tracking = false;						// do we track or no	private ImageIcon[] headingimages = new ImageIcon[8];	// holds the rocket icons	private ImageIcon trackPic;								// holds the cross for the trail	protected JLabel gameStatusLabel;						// so we can let the user know	protected int timeToWait = 200;							// default animation delay		private Thread animThread;								// for running the animation		private Border panelBorder = LineBorder.createBlackLineBorder();															// border around the game area		private RocketPanelCreator creator;						// the person who we need to															// tell when the game															// is over		// *********************************************	// constructor & init stuff	public RocketPanel(RocketPanelCreator c) {		super();		creator = c;		loadImages();		animThread = new Thread(this);	}	// get all the icons (from .gifs) that are needed	private void loadImages() {		try {			ClassLoader cl = this.getClass().getClassLoader();			headingimages[0] = new ImageIcon(cl.getResource("images/heading0.gif"));			headingimages[1] = new ImageIcon(cl.getResource("images/heading1.gif"));			headingimages[2] = new ImageIcon(cl.getResource("images/heading2.gif"));			headingimages[3] = new ImageIcon(cl.getResource("images/heading3.gif"));			headingimages[4] = new ImageIcon(cl.getResource("images/heading4.gif"));			headingimages[5] = new ImageIcon(cl.getResource("images/heading5.gif"));			headingimages[6] = new ImageIcon(cl.getResource("images/heading6.gif"));			headingimages[7] = new ImageIcon(cl.getResource("images/heading7.gif"));			trackPic = new ImageIcon(cl.getResource("images/trackPic.gif"));		} catch (Exception e) { System.out.println("Error: " + e.toString()); }	}			// *********************************************	// accessor functions	public void setGameStatusLabel(JLabel gsl) {		gameStatusLabel = gsl;	}		public JLabel getGameStatusLabel() {		return gameStatusLabel;	}		public Rocket getRocket() {		return theRocket;	}		// rather than have the panel create the rocket, it gets passed in.  This		// allows the program to be more flexible -- the same rocket panel subclass		// can be reused with different rocket settings		public void setRocket(Rocket r) {		theRocket = r;	}		public Vector getTrail() {		return theTrail;	}		public boolean getTracking() {		return tracking;	}	// *********************************************	// methods for dealing with the trail	// add the current location into the trail	public void updateTrail() {		if (tracking) {			Point p = new Point((int)theRocket.getx(), (int)theRocket.gety());			theTrail.addElement(p);		}	}		// alternate between tracking or no	public void toggleTracking() {		if (tracking) 	{ tracking = false; }		else			{ tracking = true; }	}		// *********************************************	// stuff for painting the images	// paint the track, if tracking is enabled.	protected void paintTrack(Graphics g) {		int deltax = trackPic.getIconWidth() / 2;		int deltay = trackPic.getIconHeight() / 2;				Enumeration e = theTrail.elements();				while (e.hasMoreElements()) {			Point p = (Point)e.nextElement();			trackPic.paintIcon(this, g, p.x-deltax, (getHeight()-p.y)-deltay);								// y values need to be subtracted from the componant								// height, as the screen y proceeds from top to bottom								// but we want the math to proceed from bottom to top		}	}		// paint the rocket	protected void paintRocket(Graphics g) {		int x = (int)Math.round(theRocket.getx());		int y = (int)(this.getHeight() - Math.round(theRocket.gety()));				// y values need to be subtracted from the componant				// height, as the screen y proceeds from top to bottom				// but we want the math to proceed from bottom to top		int heading = theRocket.getHeading();				int deltax = (headingimages[heading].getIconWidth() / 2);		int deltay = (headingimages[heading].getIconHeight() / 2);			headingimages[heading].paintIcon(this, g, x-deltax, y-deltay);		}		// paint the rocket and the trail.  The check for tracking is superfluous,	// as it is also a part of paintTrack, but it saves a context creation	protected void paintActionStuff(Graphics g) {		paintRocket(g);		paintTrack(g);	}		protected void setStatusLabel() {		if (gameOver())		{ gameStatusLabel.setText("You Won"); }		else if (crashed())	{ gameStatusLabel.setText("You Crashed"); }	}		// this method is where the subclasses can paint screen features.	// ie, override this method for painting stuff on screen.	protected abstract void paintGameScreen(Graphics g);		// this method should not need to be overridden	public void paintComponent(Graphics g) {		super.paintComponent(g);		panelBorder.paintBorder(this, g, 0, 0, getWidth(), getHeight());		paintGameScreen(g);		paintActionStuff(g);		setStatusLabel();	}	// *********************************************	// game status functions		// used to determine if the rocket has crashed.  Default crashing is if	// it goes outside the panel.  May need to override (esp for corner games)	public boolean crashed() {		int theX = (int)Math.round(theRocket.getx());		int theY = (int)Math.round(theRocket.gety());				if ((theX > getWidth()) || (theX < 0)) { return true; }		if ((theY > getHeight()) || (theY < 0)) { return true; }				return false;	}		// used to determine if the user won.  By default the user cannot win,	// so this method will need to be overridden	public abstract boolean gameOver();		// is true as long as the rocket has not crashed, and the user has not won	public boolean gameActive() {		return ((! crashed()) && (! gameOver()));	}		// *********************************************	// implementation of the Runnable Interface and other stuff needed for the animation		// this method is called by the thread part to create the animation	public void doRocketMove() {		theRocket.update();		updateTrail();		repaint();	}		// sets the delay	public void setWaitTime(int t) {		timeToWait = t;	}		// starts the thread running	public void start() {		animThread.start();	}	// implements the runnable interface	public void run() {		while (gameActive()) {			doRocketMove();			try {				Thread.sleep(timeToWait);			} catch (Exception ignored) {}		}		repaint();		creator.gameCompleted();	}}